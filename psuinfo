#!/usr/bin/env python3
# _*_ coding: utf-8 _*_

"""
A psutil-based command to display customizable system usage info in a single line, intended for Tint2 executors

Author: Piotr Miller
e-mail: nwg.piotr@gmail.com
Website: http://nwg.pl
Project: https://github.com/nwg-piotr/psuinfo
License: GPL3

Inspired by https://github.com/tknomanzr/scripts/blob/master/tint2/executors/cpu.py by William Bradley (@tknomanzr)
"""

import sys
import time
import os
from functools import lru_cache
import psutil


def main():
    fahrenheit = False
    names = False
    testing = False
    time_start = None
    components = "gStfM"
    separator = "  "
    home = os.getenv("HOME")
    draw_icons = False

    disks_usage = which = xfer_start = xfer_end = path_to_icon = c_name = None

    for arg in sys.argv[1:]:
        if arg in ("-h", "--help"):
            print_help()
            exit(0)

        elif arg == "-F":
            fahrenheit = True

        elif arg == "-N":
            names = True

        elif arg == "-T":
            testing = True

        elif arg.startswith("-C"):
            components = arg[2:]

        elif arg.startswith("-S"):
            if arg[2:].isdigit():
                separator = " " * int(arg[2:])
            else:
                separator = arg[2:]

        elif arg.startswith("-W"):
            if arg[2:].isdigit():
                which = int(arg[2:])

        elif arg.startswith("-I"):
            draw_icons = True
            # We can only have one icon per executor, so let's strip components to the first one
            components = arg[2]
            # exception for UL/DL speed; to assign an icon to it we need to calculate speeds first
            if components != "k":
                path_to_icon = icon_path(home, components)

        elif arg.startswith("-M"):
            # We can only have a custom name for a single component
            components = components[0]
            names = True
            c_name = arg[2:]

        elif arg.upper() == "-ALL":
            components = "gpaQStfMcWDUk"
            names = True
            testing = True

    if testing:
        time_start = int(round(time.time() * 1000))

    if "k" in components:
        try:
            xfer_start = psutil.net_io_counters()
            time.sleep(1)
            xfer_end = psutil.net_io_counters()
            ul = (xfer_end[0] - xfer_start[0]) / 1024
            dl = (xfer_end[1] - xfer_start[1]) / 1024
            # We've not selected an icon previously. Now we have enough data.
            if draw_icons:
                path_to_icon = net_icon(home, ul, dl)
        except:
            pass

    drives = []
    # Find drive names, mountpoints
    if "d" or "D" or "n" or "N" in components:
        try:
            d = psutil.disk_partitions()
            # This will store name, mountpoint
            for entry in d:
                n = entry[0].split("/")
                name = n[len(n) - 1]
                # name, mountpoint
                drive = name, entry[1]
                drives.append(drive)
        except:
            pass

    if "d" in components or "D" in components:
        try:
            disks_usage = []
            for drive in drives:
                # Search drives by path
                data = psutil.disk_usage(drive[1])
                # Store name, used, total, percent
                essential = drive[0].upper(), data[1], data[0], data[3]
                disks_usage.append(essential)
        except:
            pass

    if "n" in components or "N" in components:
        try:
            disks_usage = []
            for drive in drives:
                # Search drives by path
                data = psutil.disk_usage(drive[1])
                # Store mountpoint, used, total, percent
                essential = drive[1], data[1], data[0], data[3]
                disks_usage.append(essential)
        except:
            pass

    @lru_cache
    def temp():
        return psutil.sensors_temperatures(fahrenheit)

    @lru_cache
    def disks_entries():
        if disks_usage:
            if which is not None:
                entry = disks_usage.get(which)
                return (entry,) if entry else tuple()
            return tuple(disks_usage)
        return tuple()


    def nameAs(default):
        return c_name or default if names else ""

    # Build output after components
    output = []

    for char in components:
        if char == "g":
            if pcpu():
                output.append((c_name or "") + graph_per_cpu(pcpu()))

        elif char == "p":
            if pcpu():
                output.append(nameAs("CPU: ") + per_cpu(pcpu()))

        elif char == "a":
            if avg():
                output.append(nameAs("avCPU: ") + avg() + "%")

        elif char == "q":
            if freqs():
                output.append(
                    nameAs("CPU: ") +
                    freq_per_cpu(freqs())[0][:-1] + " GHz"
                )

        elif char == "Q":
            if freqs():
                _result = freq_per_cpu(freqs())
                output.append(
                    nameAs("CPU: ") +
                    _result[0][:-1] + "/" +
                    str(_result[1]) + " GHz"
                )

        elif char == "s":
            if speed():
                output.append(
                    nameAs("SPD: ") +
                    str(round(speed()[0] / 1000, 1)) + " GHz"
                )

        elif char == "S":
            if speed():
                output.append(
                    nameAs("avSPD: ") +
                    str(round(speed()[0] / 1000, 1)) + "/" +
                    str(round(speed()[2] / 1000, 1)) + " GHz"
                )

        elif char == "t":
            if not temp():
                continue

            if "k10temp" in temp().keys():
                # ryzen, multiple Die temperatures for threadripper/Epyc
                try:
                    ryzen_die_temps = tuple(
                        sensor.current
                        for sensor in temp()["k10temp"]
                        if sensor.label == 'Tdie' or sensor.label == 'Tctl'
                    )
                    if ryzen_die_temps:
                        temper = str(int(max(ryzen_die_temps)))
                except Exception:
                    pass
            elif "zenpower" in temp().keys():
                # zen3 is not supported in k10. Fix is to load zenpower and unload k10
                try:
                    ryzen_die_temps = tuple(
                        sensor.current
                        for sensor in temp()["zenpower"]
                        if sensor.label == 'Tdie' or sensor.label == 'Tctl'
                    )
                    if ryzen_die_temps:
                        temper = str(int(max(ryzen_die_temps)))
                except Exception:
                    pass
            elif "coretemp" in temp().keys():
                # intel
                temper = str(int(temp()["coretemp"][0][1]))
            else:
                temper = ""

            if temper:
                name = nameAs("CORE: ")
                output.append(name + temper + ("℉" if fahrenheit else "℃"))

        elif char == "f":
            if fans():
                fan0 = next(iter(fans().values()))
                output.append(nameAs("FAN: ") + str(fan0[0][1]) + "/m")

        elif char == 'm':
            if memory():
                output.append(
                    nameAs("MEM: ") +
                    str(round((memory()[0] - memory()[1]) / 1073741824, 1)) + " GB"
                )

        elif char == 'M':
            if memory():
                output.append(
                    nameAs("MEM: ") +
                    str(round((memory()[3]) / 1073741824, 1)) + "/" +
                    str(round(memory()[0] / 1073741824, 1)) + " GB"
                )

        elif char == 'c':
            if memory():
                output.append(nameAs("MEM: ") + str(memory()[2]) + "%")

        elif char == 'C':
            if memory():
                output.append(nameAs("MEM: ") + str(100 - memory()[2]) + "%")

        elif char == 'u':
            if b_time():
                up_time = int(time.time()) - b_time()
                m, s = divmod(up_time, 60)
                h, m = divmod(m, 60)
                output.append(nameAs("UP: ") + "%d:%02d" % (h, m))

        elif char == 'U':
            if b_time():
                up_time = int(time.time()) - b_time()
                m, s = divmod(up_time, 60)
                h, m = divmod(m, 60)
                output.append(nameAs("UP: ") + "%d:%02d:%02d" % (h, m, s))

        elif char == "w":
            if swap():
                output.append(
                    nameAs("SWAP: ") +
                    str(round(swap()[1] / 1073741824, 1)) + " GB"
                )

        elif char == "W":
            if swap():
                output.append(
                    nameAs("SWAP: ") +
                    str(round(swap()[1] / 1073741824, 1)) + "/" +
                    str(round(swap()[0] / 1073741824, 1)) + " GB"
                )

        elif char == "x":
            if swap():
                output.append(nameAs("SWAP: ") + str(swap()[3]) + "%")

        elif char == "d" or char == "n":
            for entry in disks_entries():
                output.append(entry[0] + ": " + str(entry[3]) + "%")

        elif char == "D" or char == "N":
            for entry in disks_entries():
                output.append(
                    entry[0] + ": " +
                    str(round(entry[1] / 1073741824, 1)) + "/" +
                    str(round(entry[2] / 1073741824, 1)) + " GB"
                )

        elif char == "k":
            if xfer_start and xfer_end:
                output.append(
                    nameAs("Net: ") +
                    '{:0.2f}  '.format((xfer_end[0] - xfer_start[0]) / 1024) +
                    '{:0.2f} kB/s'.format((xfer_end[1] - xfer_start[1]) / 1024)
                )

    if testing:
        output.append("[" + str(int((round(time.time() * 1000)) - time_start) / 1000) + "s]")

    if draw_icons:
        print(path_to_icon)
    print(separator.join(output))


@lru_cache
def pcpu():
    return psutil.cpu_percent(interval=1, percpu=True)

@lru_cache
def avg():
    _avg = str(psutil.cpu_percent(interval=1))
    if len(_avg) < 4:
        _avg = " " + _avg
    return _avg

@lru_cache
def speed():
    return psutil.cpu_freq(False)

@lru_cache
def freqs():
    return psutil.cpu_freq(True)

@lru_cache
def fans():
    return psutil.sensors_fans()

@lru_cache
def memory():
    return psutil.virtual_memory()

@lru_cache
def swap():
    return psutil.swap_memory()

@lru_cache
def b_time():
    return psutil.boot_time()

def per_cpu(result):
    string = ""
    for val in result:
        proc = str(int(round(val, 1)))
        if len(proc) < 2:
            proc = " " + proc
        string += proc + "% "
    return string


def freq_per_cpu(result):
    string = ""
    max_freq = 0
    for val in result:
        freq = str(round(val[0] / 1000, 1))
        string += freq + "|"
        max_freq = str(round(val[2] / 1000, 1))

    return string, max_freq


def graph_per_cpu(result):
    graph = "_▁▂▃▄▅▆▇███"

    string = ""
    for val in result:
        proc = int(round(val / 10, 0))
        string += graph[proc]
    return string


def print_help():

    print("\npsuinfo [-C{components}] | [-I{component}] [-F] [-N] [-S<number>] | [-S<string>] [-T] [-W{number}] [-all] [-h] [--help]")

    print("\n-C defines multiple components. -I defines a single component. If none given, -CgStfM argument will be used by default.\n")
    print("  g - (g)raphical CPU load bar")
    print("  p - (p)ercentage for each core (text)")
    print("  a - (a)verage CPU load (text)")
    print("  q - fre(q)ency for each thread")
    print("  Q - fre(Q)ency for each thread/max frequency")
    print("  s - current CPU (s)peed")
    print("  S - current/max CPU (S)peed")
    print("  t - CPU (t)emperature")
    print("  f - (f)an speed")
    print("  m - (m)emory in use")
    print("  M - (M)emory in use/total")
    print("  c - used memory per(c)entage")
    print("  C - free memory per(C)entage")
    print("  w - s(w)ap memory in use")
    print("  W - s(W)ap memory in use/total")
    print("  x - swap usage in %")
    print("  d - (d)rives as names usage in %")
    print("  D - (D)rives as names used/total")
    print("  n - drives as mou(n)tpoints usage in %")
    print("  N - drives as mou(N)tpoints used/total")
    print("  u - (u)ptime HH:MM")
    print("  U - (U)ptime HH:MM:SS")
    print("  k - current networ(k) traffic as upload/download in kB/s")

    print("\n-F - use Fahrenheit instead of ℃")
    print("-N - display field names (except for (g)raphical CPU load bar)")
    print("-S<number> - number of spaces between components (-S2 if none given)")
    print("-S<string> for custom separator (use \' | \' to include spaces)")
    print("-M<string> for custom component name (\'My custom name: \')")
    print("-T - test execution time")
    print("-all - display all possible data (for use in terminal)\n")

    print("-I<component> - show an icon before text; 1 component per executor allowed")
    print("-W<number> - select 0 to n-th element from multiple output (drives, mountpoints)\n")


def icon_path(home, component):
    icons = {'g': '',
             'p': 'cpu.svg',
             'a': 'cpu.svg',
             'q': 'cpu.svg',
             'Q': 'cpu.svg',
             's': 'cpu.svg',
             'S': 'cpu.svg',
             't': 'temp.svg',
             'f': 'fan.svg',
             'm': 'mem.svg',
             'M': 'mem.svg',
             'c': 'mem.svg',
             'C': 'mem.svg',
             'w': 'swap.svg',
             'W': 'swap.svg',
             'x': 'swap.svg',
             'd': 'hdd.svg',
             'D': 'hdd.svg',
             'n': 'hdd.svg',
             'N': 'hdd.svg',
             'u': 'up.svg',
             'U': 'up.svg'}
    try:
        f_name = icons[component]
    except KeyError:
        return ""

    return icon_to_use(home, f_name)


def net_icon(home, ul, dl):

    if ul >= 0.01 and dl >= 0.01:
        f_name = "xfer-b.svg"
    elif ul >= 0.01:
        f_name = "xfer-u.svg"
    elif dl >= 0.01:
        f_name = "xfer-d.svg"
    else:
        f_name = "xfer.svg"

    return icon_to_use(home, f_name)


def icon_to_use(home, f_name):
    icon_custom = home + '/.local/share/psuinfo/' + f_name
    icon_default = "/usr/share/psuinfo/" + f_name
    if os.path.isfile(icon_custom):
        return icon_custom
    else:
        return icon_default


if __name__ == "__main__":
    main()
